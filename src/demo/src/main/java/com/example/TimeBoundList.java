package com.example;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// הבדיקה של כל 10 מילי שניות חייבת להיות בתהליכון ושתוך כדי נוכל להתקדם בתכנית. 
//לא הגיוני לזמן כל הזמן המתודה כשיוצרים את האובייקט או בלולאת ווייל רגילה ושאז הקוד יתקע שם. מובן מאליו.
// כל עוד הרשימה קיימת התהליכון רץ.

public class TimeBoundList<E> {
  // public class TimBoundList<E> extends ArrayList{
  // זאת הייתה ההצעה של שמעון לאיך לכתוב את המחלקה ואז היה אפשר להשתמש במתודות
  // המובנות של רשימה כמו add, remove
  // או לשנות כדי לממשש אותן אחרת (דריסה) לפי מה שביקשו. והיינו
  // מוסיפים את שאר המתודות הלא קשורות שצריך.

  private List<E> data; // רשימת האיברים שנסיר
  private int timeout; // in seconds (אותו דבר עבור כל האיברים)
  private Map<E, Long> times; // מפה ששומרת את האיבר(מפתח) ואת הזמן שבו הוא הוכנס(ערך)
  // הגיוני להשתמש במפה כי כן שומרים את האיברים אבל חייב איכשהו עבור כל אחד לשמור
  // את הזמן שבו הוא הוכנס. עם מפה זה קל.
  // אופציה שנייה הייתה ליצור עבור האובייקט (ממחלקה) והשדות היו האלמנט הגנרי (ערך)
  // והזמן שלו (לןנג).
  // נעבוד על המפה במקביל לרשימה
  private List<E> removed; // רשימת האיבר שהוסרו (תזכורת: במפה אין כפילויות, אם יש שני מפתחות עם ערכים
                           // שונים דורס את הקודם) ואין אינדקס במפות שלא כמו רשימות. כדי לגשת לערך אפשר
                           // לעשות את זה רק בעזרת המפתח

  public TimeBoundList(int timeout) {
    this.timeout = timeout;
    this.data = new ArrayList<>();
    this.times = new HashMap<>();
    this.removed = new ArrayList<>(); // חייב להגדיר בכלל (לאתחל) כדי להוסיף לשם
    this.removeOld(); // ברגע שנוצרה הרשימה נראה שהיא תתחיל להתרוקן
  }

  private void removeOld() { // המתודה שמוחקת כל איבר ישן ברשימה כל זמן שהוגדר לפי טיימאאוט ובודקת כל 10
                             // מילישניות (לקורנט טיים אין מיליס)
    new Thread(() -> {
      while (true) {
        for (E key : times.keySet()) { // ריצה על המפתחות
          Long additiontime = this.times.get(key); // הערך (הזמן מתי הוסף) באותו מפתח - חייב להיות לונג עם אות גדולה כי
                                                   // הוא ערך במפה!!
          long duration = System.currentTimeMillis() - additiontime; // במילישניות
          if (duration / 1000 > this.timeout && this.data.contains(key)) { // התנאי השני כדי שלא ימשיך לנסות להסיר אותו
            // כי הרי מסירים מהרשימה ולא מהמפה ולכן בלי התנאי השני ימשיך להתקיים התנאי
            // שכאילו האיבר קיים למרות שקיים רק במפה (אנחנו לא מוציאים מהמפה).
            // פעולת ההסרה באריי ליסט רק מחזירה ערך בוליאני אם הצליח ולא מקריס
            // בגלל זה בלי התנאי השני היה ממשיך להדפיס כל 10 מילי את אותו האיבר ש׳הוסר׳ כי
            // רץ על לולאת פור כל 10 מילי כל פעם על אותה מפה שעדיין מכילה את האיבר הזה.
            // (הסלים מחוץ לפור בווייל).

            // בעצם כל 10 מילי רץ על כל המפה שוב ואם יש איבר שהתיישן מדפיס אותו ומוציא
            // מהרשימה
            // בגלל זה ההדפסות כאילו רק לפי השניות של מתי הוסר איבר

            // תזכורת: בכללי אסור להסיר איבר מאוסף שרצים עליו בפור איץ׳ כי זה משנה את הגודל
            // ויכולה להיות קריסה בגלל האינדקסים. אם כן רוצים להסיר בלולאה משתמשים באיטרטור
            this.data.remove(key); // הפור איץ׳ לא רץ על הדאטה עצמו אלא על המפה אז פשוט מסיר את האיבר מהרשימה עם
                                   // המפתח הזה. זה עובד כי אני לא משנה את האוסף שאני רצה עליו ע״י הרמוב
            // לא קריטי למחוק גם מהמפה עצמה - מיותר (מה אם נצטרך?)
            this.removed.add(key);
            System.out.println("Removed element: " + key);
          }
        }
        try {
          Thread.sleep(10);
        } catch (Exception e) {
          throw new RuntimeException();
        }
      }
    }).start();
  }

  public List<E> getRemovedElements() {
    return this.removed;
  }

  // מתודת עזר (מתודה שמכניסה למפה את האיבר במפתח ואת הזמן הנוכחי בערך ומכניסה את
  // אותו האיבר לרשימת האיברים שמוציאים ממנה)
  public void add(E element) {
    this.data.add(element);
    this.times.put(element, System.currentTimeMillis());
  }

  // מתודה שמאתחלת את הזמן של איבר מהרשימה שהיא מקבלת
  public void refresh(int index) {
    // כדי להשתמש ברשימה צריך להחזיק גם רשימה של האלמנטים
    E element = this.data.get(index);
    this.times.put(element, System.currentTimeMillis()); // עדכון האובייקט במפה (ככה מעדכנים במפה עם מפתח וערך)
  }

  public String toString() {
    return this.data.toString();
  }

  //
  // סעיף ד׳:

  // חובה לסנכרןאת הגישה בין הפעולות הפנימיות של רמוב אולד לבין הקריאת החיצוניות
  // ( מהתהליכון במיין לדוגמה לקרוא לרפרש על איבר או אד מהמחלקה) כי
  // ידוע שיהיו לנו לפחות שני תהליכונים אם ניצור את האובייקט הזה במיין ז״א אחד
  // במיין ואחד במחלקה של הרשימה אז יש גישה למפה ולרשימה במתודות רמוב אולד.

  // דוגמה לבעיה שיכולה להוביל לקריסה בסופו של דבר זה לנסות לעשות ריפרש (איפס)
  // לאיבר שכרגע הרשימה מחקה. או שהוספנו לרשימה איבר אז האינדקס של האיבר שרצינו
  // בדיוק למחוק השתנה עכשיו ואז נמחק איבר אחר בטעות וזה יצר באג בתוצאות.

  // תשובה מקובלת:
  // רואים שיש משאב משותף שפונים אליו משני תהליכונים במקביל ולכן בסופו של דבר יהיה
  // רייס קונדישן. ואפשר להוסיף את הדוגמה

  // רק שיהיה צריך לפצל אותה עם מתודת עזר שמסירה את האיבר והשנייה שמסירה שמפעילה
  // בתהליכון אין סופי את המתודת עזר (המתודת עזר תהיה מסונכרנת והשניה לא יכולה
  // להיות מסונכרנת כי יש בה לולאת ווייל טרו!) והמתודה
  // אד והמתודה רפרש יהיו מסונכרנות.
  // או שאפשר לעשות את זה עם אובייקט מנעול ולשים בלוק מסונכרן או להוסיף סינכונייזד
  // בכל המתודות האלה שישירות עובדות על המפה, אם אין בהם לולאת ווייל (כי אז בגלל
  // שזה מגביל את הגישה למתודה רק עבור תהליכון אחד כל פעם, הלולאת ווייל תהיה תקועה
  // רק עם תהליכון אחד לנצח והשאר לעולם לא יכלו להכנס).
  // בקצרה, חייב לסנכרן כי יש פנייה לאותו משאב ממקומות שונים בו זמנית שמעדכנים
  // אותו מה שיגרום בסופו של דבר לפעולות לא להתבצע כמו שצריך.

  // במילים של שי:
  // לדוגמה אפשר בטעות לעשות רפרש לאיבר בזמן שרשימה מוחקת אותו . או לדוגמה שלא
  // יודעים אם יוכנס הערך של הרפרש או לפני הרפרש כשמחקנו...
  // דוגמה נוספת היא הוספה בזמן שאני מוחקת משהו ז״א אם רציתי למחוק איבר באינדקס
  // מסוים אבל בדיוק נוסף איבר יכול לטעות למחוק אותו ולא את זה שרציתי כי המבנה
  // משתנה ונוצר איזשהו באג בתוצאות.

  // בקצרה, הסיבה היא כי יש כאן משאב משותף שהוא הרשימה דאטה והמפה טיימס אז בהכרח
  // בסופו של דבר יהיה לי רייס קונדישן. !!!

  // אגב פה לא הוספנו כי זה קצת יותר מסובך בגלל שני המשאבים אז בגלל זה זאת שאלת
  // טקסט !!!

  //
  // סעיף ה׳:
  // המנגנון כאן עובד יותר קשה כי לדוגמה אם הגדרנו את זמן ההסרה ל100 שניות אז
  // המעבד עובד
  // קשה כל 10 מילישניות לבדוק אם עבר הזמן.
  // זה נקרא מצב לונג פולינג - תשאול. שכל הזמן עושה בדיקה וזה מייגע את המעבד.
  // איך נבטל את הלולאה הזאת של כל 10 מילישניות?
  // הפתרון הכי טוב הוא לתחזק בלולאה משתנה קורנט עבור האיבר הבא (מתחילת הרשימה)
  // שצריך לצאת ולעשות להוצאה שלו
  // סליפ לפי ערך הזמן שלו.
  // כל פעם נחשב את האיבר שהכי קרוב להזדקן ועושים לו סליפ לזמן שלו אבל בזמן הזה
  // מחשבים את ההבא שצריך לצאת ככה שנעשה את הסליפ עד הזמן שלו.

  // פתרון אחר שהוא בזבזני מכיוון אחר אבל פותר את הבעיה (אבל אם משתמשים בתרדים
  // וירטואליים זו לא בעיה) זה עבור כל אובייקט במפה ניצור תרד עם ספירה לאחור כדי
  // שיוציא אותו. הסליפ בתוכו יהיה לפי ערך הזמן שלו
}
